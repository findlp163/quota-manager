# 邀请奖励额度与额度有效期技术方案

## 1. 项目概述

### 1.1 需求描述
基于现有的 Quota Manager 系统，实现邀请奖励机制：

- **被邀请用户Star奖励**：被邀请新用户首次点亮Star时额外获得25C
- **邀请人注册奖励**：被邀请新用户注册时，邀请人获得25C
- **邀请人Star奖励**：被邀请新用户首次点亮Star时，邀请人获得75C
- **有效期管理**：所有邀请奖励额度设定180天有效期（可配置），从到账日起计算
- **过期机制**：每笔额度独立计算有效期，额度扣除优先扣除最快到期的额度（FIFO）

### 1.2 现有系统能力分析

经过代码分析，现有系统具备以下基础能力：

#### 已有能力
- **策略执行框架**：完整的策略匹配和执行系统
- **条件表达式系统**：支持 `github-star()` 条件函数
- **额度管理基础**：基于 `ExpiryDate` 的过期管理和 FIFO 扣除机制
- **防重复机制**：单次策略执行记录防止重复发放（用户ID+策略ID）

#### 新功能设计
-  **邀请关系数据模型**：新增 `UserInfo.InviterID` 字段及数据库迁移脚本
-  **邀请条件函数**：新增 `has-inviter()` 条件表达式函数，表示用户为被邀请
-  **自定义有效期支持**：`QuotaStrategy.ExpiryDays` 字段，填入按有效期计算，为空则默认原逻辑
-  **邀请策略识别逻辑**：`isInviterRewardStrategy()` 方法，根据前缀 `inviter-` 判断是否奖励给邀请人
-  **180天有效期计算**：修改 `AddQuotaForStrategy` 方法支持自定义有效期
-  **完整单元测试**：三个邀请奖励策略的完整测试覆盖

## 2. 技术方案设计

### 2.1 整体架构

基于现有系统的策略执行框架，通过创建三个专门的邀请奖励策略来实现需求。系统通过 `isInvitationStrategy()` 方法识别邀请策略，自动将奖励发放给正确的接收者。

```
新用户注册 → 策略扫描 → has-inviter() 匹配 → 邀请人奖励 → 邀请人获得25c
新用户Star → 策略扫描 → has-inviter() + github-star() 匹配 → 邀请人奖励 → 邀请人获得75c
新用户Star → 策略扫描 → has-inviter() + github-star() 匹配 → 用户奖励 → 用户获得25c
```

**奖励分发逻辑**：
- 策略名以 `inviter-` 开头 → 奖励给邀请人
- 其他策略（包括 `invitee-` 开头） → 奖励给用户本人

### 2.2 核心策略设计

#### 2.2.1 邀请人注册奖励策略

**策略名称**: `inviter-register-reward`
**奖励对象**: 邀请人（通过 `isInviterRewardStrategy()` 自动识别）

```json
{
  "name": "inviter-register-reward",
  "title": "邀请人注册奖励",
  "type": "single",
  "amount": 25,
  "condition": "has-inviter()",
  "expiry_days": 180,
  "status": true
}
```

**执行逻辑**：
- 触发条件：被邀请用户注册（`has-inviter()` 返回 true）
- 奖励对象：邀请人（策略名以 `inviter-` 开头）
- 奖励金额：25c
- 有效期：180天（通过 `ExpiryDays` 字段控制）
- 执行次数：单次执行，避免重复发放

#### 2.2.2 邀请人Star奖励策略

**策略名称**: `inviter-star-reward`
**奖励对象**: 邀请人（通过 `isInviterRewardStrategy()` 自动识别）

```json
{
  "name": "inviter-star-reward", 
  "title": "邀请人Star奖励",
  "type": "single",
  "amount": 75,
  "condition": "and(has-inviter(), github-star(\"zgsm-ai.zgsm\"))",
  "expiry_days": 180,
  "status": true
}
```

**执行逻辑**：
- 触发条件：被邀请用户首次Star（`has-inviter()` 且 `github-star()` 返回 true）
- 奖励对象：邀请人（策略名以 `inviter-` 开头）
- 奖励金额：75c
- 有效期：180天（通过 `ExpiryDays` 字段控制）
- 执行次数：单次执行，避免重复发放

#### 2.2.3 被邀请用户Star奖励策略

**策略名称**: `invitee-star-reward`
**奖励对象**: 被邀请用户本人（非 `inviter-` 前缀，默认奖励给用户本人）

```json
{
  "name": "invitee-star-reward",
  "title": "被邀请用户Star奖励",
  "type": "single", 
  "amount": 25,
  "condition": "and(has-inviter(), github-star(\"zgsm-ai.zgsm\"))",
  "expiry_days": 180,
  "status": true
}
```

**执行逻辑**：
- 触发条件：被邀请用户首次Star（`has-inviter()` 且 `github-star()` 返回 true）
- 奖励对象：被邀请用户本人（非 `inviter-` 前缀，默认奖励给用户本人）
- 奖励金额：25c
- 有效期：180天（通过 `ExpiryDays` 字段控制）
- 执行次数：单次执行，避免重复发放

### 2.3 策略总结

三个邀请奖励策略完整覆盖了所有需求场景：

| 策略名称 | 触发条件 | 奖励对象 | 奖励金额 | 有效期 |
|---------|---------|---------|---------|--------|
| `inviter-register-reward` | 被邀请用户注册 | 邀请人 | 25c | 180天 |
| `inviter-star-reward` | 被邀请用户首次Star | 邀请人 | 75c | 180天 |
| `invitee-star-reward` | 被邀请用户首次Star | 用户本人 | 25c | 180天 |

### 2.4 策略识别机制

通过策略名称前缀自动识别邀请策略类型，支持完整的邀请关系处理：

```go
// getInvitationStrategyType returns the invitation strategy type prefix
// Returns: "inviter", "invitee", or "" (empty string for non-invitation strategies)
func (s *StrategyService) getInvitationStrategyType(strategy *models.QuotaStrategy) string {
    strategyNameLower := strings.ToLower(strategy.Name)
    
    if strings.HasPrefix(strategyNameLower, "inviter-") {
        return "inviter"
    }
    
    if strings.HasPrefix(strategyNameLower, "invitee-") {
        return "invitee"
    }
    
    return ""
}

// isInviterRewardStrategy checks if strategy is an inviter reward strategy
func (s *StrategyService) isInviterRewardStrategy(strategy *models.QuotaStrategy) bool {
    return s.getInvitationStrategyType(strategy) == "inviter"
}
```

**策略执行逻辑**：
```go
func (s *StrategyService) executeRecharge(strategy *models.QuotaStrategy, user *models.UserInfo, batchNumber string) error {
    // 确定配额接收者和关联用户
    var recipientUserID string
    var relatedUserID *string
    
    invitationType := s.getInvitationStrategyType(strategy)
    
    switch invitationType {
    case "inviter":
        // 邀请人奖励策略：配额给邀请人，关联被邀请用户
        recipientUserID = user.InviterID
        relatedUserID = user.ID
        
    case "invitee":
        // 被邀请用户奖励策略：配额给用户本人，关联邀请人
        recipientUserID = user.ID
        if user.InviterID != "" {
            relatedUserID = user.InviterID
        }
        
    default:
        // 普通策略：配额给用户本人，无关联用户
        recipientUserID = user.ID
        relatedUserID = nil
    }
    
    // 调用配额服务，传递关联用户信息
    err := s.quotaService.AddQuotaForStrategy(recipientUserID, strategy.Amount, strategy.ID, strategy.Name, relatedUserID)
}
```

**识别逻辑**：
- 策略名以 `inviter-` 开头 → 奖励给邀请人，RelatedUser记录被邀请用户
- 策略名以 `invitee-` 开头 → 奖励给被邀请用户，RelatedUser记录邀请人
- 其他策略 → 奖励给用户本人，无RelatedUser记录

### 2.5 配额服务增强

修改 `AddQuotaForStrategy` 方法支持策略自定义有效期和邀请关系记录：

```go
// 函数签名增强，支持关联用户记录
func (s *QuotaService) AddQuotaForStrategy(userID string, amount float64, strategyID int, strategyName string, relatedUserID *string) error {
    now := utils.NowInConfigTimezone(s.configManager.GetDirect()).Truncate(time.Second)
    
    // 获取策略信息以确定有效期
    var strategy models.QuotaStrategy
    if err := s.db.DB.First(&strategy, strategyID).Error; err != nil {
        return fmt.Errorf("failed to get strategy: %w", err)
    }
    
    // 根据策略的 ExpiryDays 计算有效期
    expiryDate := utils.CalculateExpiryDate(now, strategy.ExpiryDays)
    
    // ... 配额创建/更新逻辑 ...
    
    // 创建审计记录，支持关联用户
    auditRecord := &models.QuotaAudit{
        UserID:       userID,
        Amount:       amount,
        Operation:    models.OperationRecharge,
        StrategyID:   &strategyID,
        StrategyName: strategyName,
        ExpiryDate:   expiryDate,
    }
    
    // 设置关联用户（邀请关系）
    if relatedUserID != nil {
        auditRecord.RelatedUser = *relatedUserID
    }
    
    // ... 其余逻辑保持不变...
}
```

### 2.6 审计记录关系存储

邀请策略的审计记录将正确记录用户关系，便于追踪和显示：

| 策略类型 | UserID (配额接收者) | RelatedUser (关联用户) | 审计记录说明 |
|----------|-------------------|---------------------|-------------|
| `inviter-register-reward` | 邀请人ID | 被邀请用户ID | 邀请人注册奖励：您邀请了用户X注册成功 |
| `inviter-star-reward` | 邀请人ID | 被邀请用户ID | 邀请人Star奖励：您邀请了用户X Star成功 |
| `invitee-star-reward` | 被邀请用户ID | 邀请人ID | 被邀请人Star奖励：您受用户Y邀请并Star成功 |

**现有审计显示逻辑自动适配**：
```go
switch result[i].StrategyName {
case "inviter-register-reward":
    result[i].Description = "邀请人注册奖励：您邀请了用户" + record.RelatedUser + "注册成功"
case "inviter-star-reward":
    result[i].Description = "邀请人Star奖励：您邀请了用户" + record.RelatedUser + "Star成功"
case "invitee-star-reward":
    result[i].Description = "被邀请人Star奖励：您受" + record.RelatedUser + "邀请并Star成功"
}
```

### 2.7 触发机制

Single 类型策略的触发机制有以下方式：

#### 2.7.1 定时自动扫描触发
- **触发机制**：通过调度器服务（SchedulerService）定时执行
- **触发函数**：`TraverseSingleStrategies()`
- **扫描间隔配置**（优先级从高到低）：
  - 使用配置文件中的 `scheduler.scan_interval` 设置
  - 配置：`"0 0 * * * *"`（每小时执行一次，生产环境配置更快）
  - 如果未配置，根据运行模式使用默认值：
    - **debug 模式**：`"*/10 * * * * *"`（每10秒执行一次）
    - **release 模式**：`"0 0 * * * *"`（每小时执行一次）

#### 2.7.2 执行逻辑特点
- **一次性执行**：single 类型策略对每个用户只执行一次
- **重复执行检查**：通过 `hasExecuted(strategy.ID, user.ID)` 检查是否已执行过
- **条件评估**：每次扫描时会重新评估策略条件（`strategy.Condition`）
- **用户范围**：扫描所有启用的用户
- **策略范围**：只处理状态为启用（`status = true`）且类型为 `"single"` 的策略

#### 2.7.3 触发流程
```
定时器/API触发 → TraverseSingleStrategies() → 
加载用户列表 → 加载启用的single策略 → 
遍历每个策略 → 遍历每个用户 → 
检查是否已执行 → 评估策略条件 → 
条件满足则执行充值
```

### 2.8 防重复机制

现有系统的单次执行策略（`type: "single"`）配合执行记录表（`quota_execute`）确保每个策略对每个用户只执行一次，天然防止重复发放。

## 3. 实施方案

### 3.1 数据库变更

新增表字段：
- `auth_users.inviter_id` - 邀请人id
- `quota_strategy.expiry_days` - 自定义有效天数

### 3.2 代码修改点

#### 3.2.1 策略识别逻辑新增
**文件**: `internal/services/strategy.go`

**优化为**: 基于前缀的邀请人奖励识别
```go
func (s *StrategyService) isInviterRewardStrategy(strategy *models.QuotaStrategy) bool {
    return strings.HasPrefix(strings.ToLower(strategy.Name), "inviter-")
}
```

#### 3.2.2 有效期计算逻辑封装
**文件**: `internal/utils/expiry.go`
**当前实现**: `AddQuotaForStrategy()` 方法硬编码使用月底有效期
**实现**: 新封装通用的有效期计算函数 `CalculateExpiryDate`，若设置了有效天数，则按有效天数计算过期日期。否则默认有效期为月底

**新增通用函数**：
```go
// CalculateExpiryDate calculates quota expiry date based on strategy configuration and base time
func CalculateExpiryDate(now time.Time, expiryDays *int) time.Time {
    if expiryDays != nil && *expiryDays > 0 {
        // Use strategy specified expiry days, time fixed to 23:59:59
        targetDate := now.AddDate(0, 0, *expiryDays)
        return time.Date(targetDate.Year(), targetDate.Month(), targetDate.Day(), 23, 59, 59, 0, now.Location())
    } else {
        // Use default end-of-month expiry
        return time.Date(now.Year(), now.Month()+1, 0, 23, 59, 59, 0, now.Location())
    }
}
```

**在多处使用此通用函数**：
- `QuotaService.AddQuotaForStrategy()` - 添加额度时计算有效期
- `StrategyService.executeRecharge()` - 策略执行时计算有效期

**使用示例**：
```go
// In AddQuotaForStrategy
expiryDate := utils.CalculateExpiryDate(now, strategy.ExpiryDays)

// In executeRecharge  
expiryDate := utils.CalculateExpiryDate(now, strategy.ExpiryDays)
```

#### 3.2.3 策略配置创建
**方式**: 通过管理接口创建4个邀请奖励策略配置

### 3.3 配置参数

需要在配置文件中设置目标 GitHub 项目：

```yaml
github_star_check:
  enabled: true
  required_repo: "your-org/your-project"  # 目标项目
```

### 3.4 部署步骤

1. **代码部署**：部署包含修改的新版本
2. **策略创建**：创建4个邀请奖励策略
3. **配置更新**：更新 GitHub Star 检查配置
4. **功能验证**：测试注册和Star点亮流程
5. **监控启动**：监控策略执行和额度发放情况

## 4. 技术风险与应对

### 4.1 潜在风险

#### 4.1.1 邀请关系验证
**风险**：恶意用户可能伪造邀请关系
**应对**：依赖上游注册系统确保 `InviterID` 的准确性，只允许注册时填入

#### 4.1.2 策略执行时序问题  
**风险**：注册奖励和Star奖励可能在同一次扫描中执行
**应对**：通过策略名称和执行记录确保独立执行，single类型策略天然防重复

#### 4.1.3 Star状态同步延迟
**风险**：GitHub Star 状态更新可能有延迟
**应对**：通过定时扫描机制，允许一定延迟，确保最终一致性

### 4.2 性能考虑

#### 4.2.1 策略扫描频率
**建议**：根据用户注册频率调整扫描间隔，避免过于频繁的扫描

#### 4.2.2 数据库查询优化
**现状**：已有相关索引支持高效查询
**监控**：关注 `has-inviter()` 和 `github-star()` 条件的查询性能

## 5. 测试方案

### 5.1 单元测试

#### 5.1.1 邀请奖励策略测试
-  `testStrategyInviteRegister` - 邀请人注册奖励测试
-  `testStrategyInviteStar` - 邀请人Star奖励测试  
-  `testStrategyInviteUserStar` - 被邀请用户Star奖励测试
-  `testExpiryDaysStrategy` - 自定义有效期功能测试

#### 5.1.2 核心功能测试覆盖
-  策略识别逻辑（`isInviterRewardStrategy()` 方法）
-  通用有效期计算（`utils.CalculateExpiryDate()` 函数）
-  条件表达式（`has-inviter()` 和 `github-star()` 组合）
-  奖励分发逻辑（邀请人 vs 用户本人）
-  防重复执行机制（single类型策略）
-  InviterID 空指针保护和错误处理

### 5.2 集成测试

#### 5.2.1 完整流程测试
1.  创建邀请关系的新用户注册
2.  验证邀请人注册奖励正确发放（邀请人25c）
3.  用户点亮Star操作
4.  验证Star奖励正确发放（被邀请用户25c，邀请人75c）
5.  验证自定义有效期功能（7天、180天等）
6.  验证防重复执行机制

#### 5.2.2 边界情况测试
-  无邀请人的用户注册（不触发邀请奖励）
-  已执行过的策略重复触发（正确跳过）
-  邀请人ID为空的错误处理
-  GitHub Star条件精确匹配
-  自定义有效期 vs 默认月底有效期对比

### 5.3 测试执行方式

#### 5.3.1 测试运行命令
```bash
cd test
# 运行所有测试（包含261个测试用例）
go run *.go
```

#### 5.3.2 测试覆盖统计
- **邀请奖励策略测试**: 3个核心测试函数
- **有效期功能测试**: 1个专门测试函数

## 6. 总结

### 6.1 方案优势

1. **基于现有框架**：充分利用现有策略执行框架，减少架构性改动
2. **高度可配置**：通过策略配置灵活控制奖励规则
3. **防重复机制**：现有的单次执行策略天然防止重复发放
4. **完整审计**：所有奖励发放都有完整的审计记录
5. **灵活扩展**：可轻松调整奖励金额、有效期等参数

### 6.2 开发工作量

#### 实际工作量统计
-  **熟悉项目&搭建环境**：1个工作日
-  **数据库迁移**：0.5个工作日
-  **核心开发**：1个工作日
-  **单元测试**：1个工作日
-  **部署验证**：1个工作日
- **总计**：4.5个工作日

### 6.3 部署步骤

1. **数据库迁移**：
   ```bash
   # 执行迁移脚本添加新字段
   mysql < scripts/migration_add_fields.sql
   ```

2. **代码部署**：
   - 提交所有新增代码到git
   - 部署到测试环境验证
   - 生产环境部署

3. **策略配置**：
   - 通过管理界面创建三个邀请奖励策略
   - 配置正确的条件表达式和有效期

4. **监控验证**：
   - 验证策略执行日志
   - 检查奖励发放记录
   - 监控系统性能指标

系统具备良好的可扩展性和可维护性，为后续功能扩展奠定了坚实基础。
